<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CSV to Stacked Area Chart</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            color: #333;
            margin: 0;
            padding: 0;
        }
        
        .header {
            background-color: #4CAF50;
            color: white;
            padding: 10px 0;
            text-align: center;
            font-size: 24px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .controls label {
            margin: 0 10px;
            font-weight: bold;
        }
        
        .controls input[type="range"] {
            margin: 0 10px;
        }
        
        .controls select {
            margin: 0 10px;
            padding: 5px;
            font-size: 14px;
        }
        
        #chart {
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto; /* Ensure the chart is scrollable on smaller screens */
        }
        
        .tooltip {
            position: absolute;
            text-align: center;
            width: auto;
            height: auto;
            padding: 5px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0.9;
        }

        /* Style for the mode button */
        .mode-button {
            margin: 0 10px;
            padding: 5px 10px;
            font-size: 14px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .mode-button:hover {
            background-color: #45a049;
        }
    </style>
    <script src="https://d3js.org/d3.v6.min.js"></script>
</head>
<body>
    <div class="header">CSV to Stacked Area Chart</div>
    <div class="controls">
        <label for="valueSlider">
            <select id="variableSelect">
                <option value="var_year">Year</option>
                <option value="var_altitude">Altitude</option>
                <!-- Add more variables as needed -->
            </select>
         </label>
        <input type="range" min="1996" max="2024" value="2020" class="slider" id="valueSlider">
        <span id="selectedValue">2020</span>
        <!-- Add the mode button -->
        <button id="modeButton" class="mode-button">Max</button>
    </div>
    <div id="chart"></div>
    <div id="alpes"></div>
    <div id="pyren"></div>
    <script>
        // Global variables to store state and processed data
        let scaleNeige = 100;
        let definedDate = 2020;
        let selectedVariable = 'var_year';
        let processedData = {};
        let currentMode = 'max'; // Default mode is "Max"

        // DOM elements for interaction
        const variableSelect = document.getElementById('variableSelect');
        const slider = document.getElementById('valueSlider');
        const output = document.getElementById('selectedValue');
        const modeButton = document.getElementById('modeButton');

        // Initialize the displayed year
        output.innerHTML = slider.value;

        // Event listener for the slider
        slider.oninput = function() {
            definedDate = this.value;
            output.innerHTML = definedDate;
            updateChart();
        }

        function updateSliderRange() {
            if (selectedVariable === 'var_year') {
                // For "Year", set the range to 1996 to 2024
                slider.min = 1996;
                slider.max = 2024;
                slider.value = definedDate; // Keep the current value
            } else if (selectedVariable === 'var_altitude') {
                // For "Altitude", set the range to the minimum and maximum altitude in the data
                const altitudes = infoData.map(d => +d.Altitude);
                const minAltitude = Math.min(...altitudes);
                const maxAltitude = Math.max(...altitudes);
                slider.min = minAltitude;
                slider.max = maxAltitude;
                slider.value = minAltitude;
            }
            output.innerHTML = slider.value; // Update the displayed value
        }

        // Event listener for the variable dropdown
        variableSelect.onchange = function() {
            selectedVariable = this.value;
            updateChart();
            updateHeightmap();
            updateSliderRange();
        }

        // Event listener for the mode button
        modeButton.onclick = function() {
            // Toggle between "Max" and "Average" modes
            currentMode = currentMode === 'max' ? 'average' : 'max';
            modeButton.textContent = currentMode.charAt(0).toUpperCase() + currentMode.slice(1); // Update button text
            updateChart(); // Update the chart based on the new mode
            updateHeightmap();
        }

        /**
         * Preprocesses the raw data from CSV files.
         * @param {Array} infoData - Data from the "info.csv" file.
         * @param {Array} nivoData - Data from the "nivo.csv" file.
         * @returns {Object} - Processed data mapped by year.
         */
        function preprocessData(infoData, nivoData) {
            const yearlyDataMAX = {};
            const yearlyDataAVERAGE = {};

            // Aggregate data by year and station MAX and AVERAGE
            nivoData.forEach(d => {
                const year = d.date.slice(0, 4);
                // MAX
                if (!yearlyDataMAX[year]) {
                    yearlyDataMAX[year] = {};
                }
                if (!yearlyDataMAX[year][d.numer_sta]) {
                    yearlyDataMAX[year][d.numer_sta] = 0; 
                }
                if (+d.ht_neige > yearlyDataMAX[year][d.numer_sta]) {
                    yearlyDataMAX[year][d.numer_sta] = +d.ht_neige;
                }
                // AVERAGE
                if (!yearlyDataAVERAGE[year]) {
                    yearlyDataAVERAGE[year] = {};
                }
                if (!yearlyDataAVERAGE[year][d.numer_sta]) {
                    yearlyDataAVERAGE[year][d.numer_sta] = { sum: 0, count: 0 };
                }
                yearlyDataAVERAGE[year][d.numer_sta].sum += +d.ht_neige;
                yearlyDataAVERAGE[year][d.numer_sta].count += 1;
            });

            // Calculate the average snow height for each station and year
            Object.keys(yearlyDataAVERAGE).forEach(year => {
                Object.keys(yearlyDataAVERAGE[year]).forEach(key => {
                    yearlyDataAVERAGE[year][key] = yearlyDataAVERAGE[year][key].sum / yearlyDataAVERAGE[year][key].count;
                });
            });

            // Return the processed data based on the current mode
            if (currentMode === 'max') {
                return mapPreprocessData(yearlyDataMAX);
            } else {
                return mapPreprocessData(yearlyDataAVERAGE);
            }
        }

        function mapPreprocessData(yearlyData) {
            // Map the processed data to a format suitable for the chart
            const neigeDataMap = {};
            for (const year in yearlyData) {
                neigeDataMap[year] = infoData.map(d => ({
                    Latitude: +d.Latitude,
                    Longitude: +d.Longitude,
                    Altitude: +d.Altitude,
                    ht_neige: (yearlyData[year][d.ID] || 0) * scaleNeige,
                    ID: d.ID,
                    Nom: d.Nom
                })).filter(d => d.ht_neige !== 0);

                // Sort data by altitude for better visualization
                neigeDataMap[year].sort((a, b) => a.Altitude - b.Altitude);
            }

            return neigeDataMap;
        }

        /**
         * Updates the chart based on the selected year and variable.
         */
        function updateChart() {
            processedData = preprocessData(infoData, nivoData); // Re-process data based on the current mode
            const neigeData = processedData[definedDate.toString()];

            // Prepare data for the stacked area chart
            const stackData = neigeData.map((d, i) => ({
                index: i,
                Altitude: d.Altitude,
                ht_neige: d.ht_neige,
                Latitude: d.Latitude,
                Longitude: d.Longitude,
                ID: d.ID,
                Nom: d.Nom
            }));

            createStackedAreaChart(stackData);
        }

        /**
         * Updates the heightmap based on the selected year
         */
        function updateHeightmap() {
            processedData = preprocessData(infoData, nivoData);
            const neigeData = processedData[definedDate.toString()]

            // Prepare data for the stacked area heightmap
            // Prepare data for the stacked area chart
            const stackData = neigeData.map((d, i) => ({
                index: i,
                Altitude: d.Altitude,
                ht_neige: d.ht_neige,
                Latitude: d.Latitude,
                Longitude: d.Longitude,
                ID: d.ID,
                Nom: d.Nom
            }));

            createHeightmap(stackData);
        }

        /**
         * Creates or updates the heightmap
         * @param {array} data - Processed data for the heightmap.
         */
        function createHeightmap(data) {
            // Clear any existing elements
            d3.select('#alpes').selectAll("*").remove();
            d3.select('#pyren').selectAll("*").remove();

            // Define chart margins, width and height
            const margin = { top: 20, right: 30, bottom: 30, left: 50 };
            const width = Math.max(928, window.innerWidth - 40) - margin.left - margin.right; // Responsive width
            const height = 500 - margin.top - margin.bottom;

            // Define the color sequence from light green to gray
            const z_colors = [
                "#28fa14", // Light green
                "#909e8f", // Regular gray
            ];

            // Define the color sequence from light light gray to white
            const s_colors = [
                "#EEEEEE", // Light light gray
                "#FFFFFF", // White
                "#DDEEFF" // Light blue
            ];

            // Create data points
            const points = data.map(d => ({
                x: d.Longitude,
                y: d.Latitude,
                z: d.Altitude,
                s: d.ht_neige
            }));

            const alpes_points = points.filter(p => p.x > 5.0);
            const pyren_points = points.filter(p => p.x < 2.5);

            // Create border points to each area
            const x_e = 0.38;
            const y_e = 0.13;

            const alpes_border = [
                { x : d3.min(alpes_points, d => d.x) - x_e , y : d3.min(alpes_points, d => d.y) - y_e , z : 60.0 , s : 0.0 } , // sw
                { x : d3.max(alpes_points, d => d.x) + x_e , y : d3.min(alpes_points, d => d.y) - y_e , z : 60.0 , s : 0.0 } , // se
                { x : d3.min(alpes_points, d => d.x) - x_e , y : d3.max(alpes_points, d => d.y) + y_e , z : 60.0 , s : 0.0 } , // nw
                { x : d3.max(alpes_points, d => d.x) + x_e , y : d3.max(alpes_points, d => d.y) + y_e , z : 60.0 , s : 0.0 }   // ne
            ];

            const pyren_border = [
                { x : d3.min(pyren_points, d => d.x) - x_e , y : d3.min(pyren_points, d => d.y) - y_e , z : 60.0 , s : 0.0 } , // sw
                { x : d3.max(pyren_points, d => d.x) + x_e , y : d3.min(pyren_points, d => d.y) - y_e , z : 60.0 , s : 0.0 } , // se
                { x : d3.min(pyren_points, d => d.x) - x_e , y : d3.max(pyren_points, d => d.y) + y_e , z : 60.0 , s : 0.0 } , // nw
                { x : d3.max(pyren_points, d => d.x) + x_e , y : d3.max(pyren_points, d => d.y) + y_e , z : 60.0 , s : 0.0 }   // ne
            ];

            // Divide each border (not yet implemented)
            const x_d = 8;
            const y_d = 3;

            // Add those points
            alpes_border.forEach(p => alpes_points.push(p));
            pyren_border.forEach(p => pyren_points.push(p));

            // Define x and y scales
            const alpes_x = d3.scaleLinear()
                .domain([d3.min(alpes_points, d => d.x), d3.max(alpes_points, d => d.x)])
                .range([0, width]);

            const alpes_y = d3.scaleLinear()
                .domain([d3.min(alpes_points, d => d.y), d3.max(alpes_points, d => d.y)])
                .range([height, 0]);
            
            // Define x and y scales
            const pyren_x = d3.scaleLinear()
                .domain([d3.min(pyren_points, d => d.x), d3.max(pyren_points, d => d.x)])
                .range([0, width]);

            const pyren_y = d3.scaleLinear()
                .domain([d3.min(pyren_points, d => d.y), d3.max(pyren_points, d => d.y)])
                .range([height, 0]);

            // Create Voronoi Diagram
            const alpes_delaunay = d3.Delaunay.from(alpes_points, p => alpes_x(p.x), p => alpes_y(p.y));
            const alpes_voronoi  = alpes_delaunay.voronoi([0, 0, width, height]);
            
            const pyren_delaunay = d3.Delaunay.from(pyren_points, p => pyren_x(p.x), p => pyren_y(p.y));
            const pyren_voronoi  = pyren_delaunay.voronoi([0, 0, width, height]);

            // Create color scale for altitude (z) and snow height (s)
            const z_colorScale = d3.scaleSequential()
                .domain([d3.min(points, p => p.z), d3.max(points, p => p.z)])
                .range([0, z_colors.length - 1]);
            
            const s_colorScale = d3.scaleSequential()
                .domain([d3.min(points, p => p.s), d3.max(points, p => p.s)])
                .range([0, s_colors.length - 1]);
            
            // Function to find the interpolation color
            function interpolateColor(t, c) {
                const index = Math.floor(t);
                const fraction = t - index;
                let start = index < c.length ? c[index] : c[c.length - 1];
                let end = index + 1 < c.length ? c[index + 1] : c[c.length - 1];
                return d3.interpolateRgb(start, end)(fraction);
            }

            // Create the SVG containers
            const svgAlpes = d3.select("#alpes")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("style", "border: 2px solid black;")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const svgPyren = d3.select("#pyren")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("style", "border: 2px solid black;")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Function to find the gradient color for the Alpes
            function createAlpesGradient(id, colors) {
                const gradient = svgAlpes.append("defs")
                    .append("linearGradient")
                    .attr("id", id)
                    .attr("x1", "0%")
                    .attr("y1", "0%")
                    .attr("x2", "100%")
                    .attr("y2", "100%");

                colors.forEach((color, index) => {
                    gradient.append("stop")
                        .attr("offset", `${(index / (colors.length - 1)) * 100}%`)
                        .attr("style", `stop-color:${color};stop-opacity:1`);
                });
            }

            // Function to find the gradient color for the Pyrennées
            function createPyrenGradient(id, colors) {
                const gradient = svgPyren.append("defs")
                    .append("linearGradient")
                    .attr("id", id)
                    .attr("x1", "0%")
                    .attr("y1", "0%")
                    .attr("x2", "100%")
                    .attr("y2", "100%");

                    colors.forEach((color, index) => {
                        gradient.append("stop")
                            .attr("offset", `${(index / (colors.length - 1)) * 100}%`)
                            .attr("style", `stop-color:${color};stop-opacity:1`);
                    });
            }

            // Function to sort neighbors according to angle
            function sortAlpesNeighbors(center, neighbors) {
                return neighbors.sort((a, b) => {
                    const angleA = Math.atan2(alpes_points[a].y - center.y, alpes_points[a].x - center.x);
                    const angleB = Math.atan2(alpes_points[b].y - center.y, alpes_points[b].x - center.x);
                    return angleA - angleB;
                });
            }

            // Draw Voronoi diagram
            svgAlpes.selectAll('path')
                .data(alpes_voronoi.cellPolygons())
                .join('path')
                .attr("d", (d, i) => !d ? null : `M${d.join("L")}Z`)
                .attr("fill", (d, i) => {
                    if (!d) return null;
                    const neighbors = alpes_delaunay.neighbors(i);
                    const sortedNeighbors = sortAlpesNeighbors(alpes_points[i], neighbors);
                    const colors = [interpolateColor(s_colorScale(alpes_points[i].s), s_colors)];
                    sortedNeighbors.forEach(neighborIndex => {
                        colors.push(interpolateColor(s_colorScale(alpes_points[neighborIndex].s), s_colors));
                    });
                    const gradientId = `gradient-${i}`;
                    createAlpesGradient(gradientId, colors);
                    return `url(#${gradientId})`;
                    })
                .attr("class", "polygon");
            
            // Draw points as rectangles
            svgAlpes.selectAll('circle')
                .data(alpes_points)
                .enter()
                .append('circle')
                .attr('cx', p => alpes_x(p.x))
                .attr('cy', p => alpes_y(p.y))
                .attr('r', 2)
                .attr('fill', 'black')
                .attr("class", "point");
            
            // Draw the surrounding black border
            svgAlpes.append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', width)
                .attr('height', height)
                .attr('fill', 'none')
                .attr('stroke', 'black')
                .attr('stroke-width', 1);

            // Add title to the graph
            const alpes_title_margin = 30;
            const alpes_title = svgAlpes.append('text')
                .attr('x', width / 2)
                .attr('y', height + alpes_title_margin)
                .attr('text-anchor', 'middle')
                .attr('font-size', '16px')
                .attr('font-weight', 'bold')
                .text('Région des Alpes');
            
            svgAlpes.attr('height', height + alpes_title_margin * 2);
            
            // Draw the points as rectangle
            svgPyren.selectAll('rect')
                .data(data)
                .enter()
                .append('rect')
                .attr('x', d => pyren_x(d.Longitude) - 20)
                .attr('y', d => pyren_y(d.Latitude) - 20)
                .attr('width', 20)
                .attr('height', 20)
                .attr('fill', d => interpolateColor(s_colorScale(d.Altitude + d.ht_neige), s_colors))

            // Add title to the graph
            const pyren_title_margin = 30;
            const pyren_title = svgPyren.append('text')
                .attr('x', width / 2)
                .attr('y', height + pyren_title_margin)
                .attr('text-anchor', 'middle')
                .attr('font-size', '16px')
                .attr('font-weight', 'bold')
                .text('Région des Pyrennées');
        }

        /**
         * Creates or updates the stacked area chart.
         * @param {Array} data - Processed data for the chart.
         */
        function createStackedAreaChart(data) {
            // Clear any existing chart elements
            d3.select("#chart").selectAll("*").remove();

            // Define chart margins, width, and heightalpes_voronoi
            const margin = { top: 20, right: 30, bottom: 30, left: 50 };
            const width = Math.max(928, window.innerWidth - 40) - margin.left - margin.right; // Responsive width
            const height = 500 - margin.top - margin.bottom;

            // Create the SVG container
            const svg = d3.select("#chart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Add a tooltip
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            // Define x and y scales
            const x = d3.scaleLinear()
                .domain([0, data.length - 1])
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.Altitude + d.ht_neige)])
                .range([height, 0]);

            // Define color scale for the stacked layers
            const color = d3.scaleOrdinal()
                .domain(["Altitude", "ht_neige"])
                .range(["brown", "blue"]);

            // Create a stack generator
            const stack = d3.stack()
                .keys(["Altitude", "ht_neige"]);

            // Generate stacked data
            const series = stack(data);

            // Define the area generator
            const area = d3.area()
                .x((d, i) => x(i))
                .y0(d => y(d[0]))
                .y1(d => y(d[1]));

            // Draw the stacked area layers
            svg.selectAll(".layer")
                .data(series)
                .enter().append("path")
                .attr("class", "layer")
                .attr("fill", d => color(d.key))
                .attr("d", area)
                .on("mouseover", function(event, d) {
                    const [mouseX, mouseY] = d3.pointer(event);
                    const x0 = x.invert(mouseX);
                    const i = Math.round(x0);
                    const dataPoint = data[i];
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", 0.9);
                    tooltip.html(`ID: ${dataPoint.ID}<br>Nom: ${dataPoint.Nom}<br>Altitude: ${dataPoint.Altitude}<br>ht_neige: ${dataPoint.ht_neige / scaleNeige}`)
                        .style("left", (event.pageX + 5) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // Add x-axis
            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(data.length));

            // Add y-axis
            svg.append("g")
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(d => d))
                .selectAll(".tick line").attr("stroke-opacity", 0.1);

            // Add a horizontal line at y=0
            svg.append("line")
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", y(0))
                .attr("y2", y(0))
                .attr("stroke", "black");
        }

        // Load and process data from CSV files
        let infoData, nivoData;
        Promise.all([
            d3.csv("info.csv"),
            d3.csv("nivo.csv")
        ]).then(([infoDataCSV, nivoDataSCV]) => {
            infoData = infoDataCSV;
            nivoData = nivoDataSCV;
            processedData = preprocessData(infoData, nivoData);
            updateChart(); // Initial chart display
            updateHeightmap();
        }).catch(error => {
            console.error("Error loading CSV files:", error);
        });

        // Make the chart responsive
        window.addEventListener("resize", updateChart);
        window.addEventListener("resize", updateHeightmap);
    </script>
</body>
</html>
